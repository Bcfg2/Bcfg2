#!/usr/bin/env python
"""Query reporting system for client status."""
__revision__ = '$Revision$'

import os
import sys
import logging
from metargs import Option, MissingConfigArgumentError
import Bcfg2.Options

try:
    import Bcfg2.Server.Reports.settings
except MissingConfigArgumentError:
    logging.exception("Your bcfg2.conf is currently missing the statistics section which "
          "is necessary for the reporting interface. Please see bcfg2.conf(5) "
          "for more details.")
    try:
        # Parse arguments here to display help if it's available
        Bcfg2.Options.args()
    except:
        pass
    sys.exit(1)

project_directory = os.path.dirname(Bcfg2.Server.Reports.settings.__file__)
project_name = os.path.basename(project_directory)
sys.path.append(os.path.join(project_directory, '..'))
project_module = __import__(project_name, '', '', [''])
sys.path.pop()
# Set DJANGO_SETTINGS_MODULE appropriately.
os.environ['DJANGO_SETTINGS_MODULE'] = '%s.settings' % project_name

from Bcfg2.Server.Reports.reports.models import Client
import datetime

FIELDS = ['name', 'state', 'time', 'total', 'good', 'bad']

def timecompare(client1, client2):
    """Compares two clients by their timestamps."""
    return cmp(client1.current_interaction.timestamp, \
               client2.current_interaction.timestamp)

def namecompare(client1, client2):
    """Compares two clients by their names."""
    return cmp(client1.name, client2.name)

def statecompare(client1, client2):
    """Compares two clients by their states."""
    clean1 = client1.current_interaction.isclean()
    clean2 = client2.current_interaction.isclean()

    if clean1 and not clean2:
        return -1
    elif clean2 and not clean1:
        return 1
    else:
        return 0

def totalcompare(client1, client2):
    """Compares two clients by their total entry counts."""
    return cmp(client2.current_interaction.totalcount, \
               client1.current_interaction.totalcount)

def goodcompare(client1, client2):
    """Compares two clients by their good entry counts."""
    return cmp(client2.current_interaction.goodcount, \
               client1.current_interaction.goodcount)

def badcompare(client1, client2):
    """Compares two clients by their bad entry counts."""
    return cmp(client2.current_interaction.totalcount - \
               client2.current_interaction.goodcount,   \
               client1.current_interaction.totalcount - \
               client1.current_interaction.goodcount)

def crit_compare(criterion, client1, client2):
    """Compares two clients by the criteria provided in criterion."""
    for crit in criterion:
        comp = 0
        if crit == 'name':
            comp = namecompare(client1, client2)
        elif crit == 'state':
            comp = statecompare(client1, client2)
        elif crit == 'time':
            comp = timecompare(client1, client2)
        elif crit == 'total':
            comp = totalcompare(client1, client2)
        elif crit == 'good':
            comp = goodcompare(client1, client2)
        elif crit == 'bad':
            comp = badcompare(client1, client2)
        
        if comp != 0:
            return comp
    
    return 0

def print_fields(fields, cli, max_name, entrydict):
    """
    Prints the fields specified in fields of cli, max_name
    specifies the column width of the name column.
    """
    fmt = ''
    for field in fields:
        if field == 'name':
            fmt += ("%%-%ds   " % (max_name))
        else:
            fmt += "%s   "
    fdata = []
    for field in fields:
        if field == 'time':
            fdata.append(str(cli.current_interaction.timestamp))
        elif field == 'state':
            if cli.current_interaction.isclean():
                fdata.append("clean")
            else:
                fdata.append("dirty")
        elif field == 'total':
            fdata.append("%5d" % cli.current_interaction.totalcount)
        elif field == 'good':
            fdata.append("%5d" % cli.current_interaction.goodcount)
        elif field == 'bad':
            fdata.append("%5d" % cli.current_interaction.totalcount \
                               - cli.current_interaction.goodcount)
        else:
            try:
                fdata.append(getattr(cli, field))
            except:
                fdata.append("N/A")

    display = fmt % tuple(fdata)
    if len(entrydict) > 0:
        display += "   "
        display += str(entrydict[cli])
    print(display)

def print_entry(item, max_name):
    fmt = ("%%-%ds   " % (max_name))
    fdata = item.entry.kind + ":" + item.entry.name
    display = fmt % (fdata)
    print(display)

def print_totals(c_inst):
    managed = c_inst.current_interaction.totalcount
    good = c_inst.current_interaction.goodcount
    print("Total managed entries: %d (good: %d)" % (managed, good))

def print_bad(c_inst):
    baditems = c_inst.current_interaction.bad()

    if len(baditems) > 0:
        print("Bad Entries:")
        max_name = -1
        for item in baditems:
            if len(item.entry.name) > max_name:
                max_name = len(item.entry.name)
        for item in baditems:
            print_entry(item, max_name)

def print_modified(c_inst):
    modifieditems = c_inst.current_interaction.modified()

    if len(modifieditems) > 0 and ('-m' in args or '-s' in args):
        print "Modified Entries:"
        max_name = -1
        for item in modifieditems:
            if len(item.entry.name) > max_name:
                max_name = len(item.entry.name)
        for item in modifieditems:
            print_entry(item, max_name)

def print_extra(c_inst):
    extraitems = c_inst.current_interaction.extra()

    if len(extraitems) > 0:
        print("Extra Entries:")
        max_name = -1
        for item in extraitems:
            if len(item.entry.name) > max_name:
                max_name = len(item.entry.name)
        for item in extraitems:
            print_entry(item, max_name)

def select_clients(entry_types, clients, itemgetter):
    """
    Returns a list of all clients that match one of the entry_types
    (possible matches are selected using itemgetter)
    """
    entrydict = {}
    results = []
    for kind, name in entry_types:
        for client in clients:
            for item in itemgetter(client):
                if item.entry.name == name and item.entry.kind == kind:
                    results.append(client)
                    entrydict.setdefault(client, []).append(name)
                    break

    return results, entrydict

fields = ""
sort = ""
badentry = ""
modifiedentry = ""
extraentry = ""
expire = ""
singlehost = ""

usage = """Usage: bcfg2-reports [option] ...

Options and arguments (and corresponding environment variables):
-a                        : shows all hosts, including expired hosts
-b NAME                   : single-host mode - shows bad entries from the
                            current interaction of NAME
-c                        : shows only clean hosts
-d                        : shows only dirty hosts
-e NAME                   : single-host mode - shows extra entries from the
                            current interaction of NAME
-h                        : shows help and usage info about bcfg2-reports
-m NAME                   : single-host mode - shows modified entries from the
                            current interaction of NAME
-s NAME                   : single-host mode - shows bad, modified, and extra
                            entries from the current interaction of NAME
-t NAME                   : single-host mode - shows total number of managed and
                            good entries from the current interaction of NAME
-x NAME                   : toggles expired/unexpired state of NAME
--badentry=KIND,NAME      : shows only hosts whose current interaction has bad
                            entries in of KIND kind and NAME name; if a single
                            argument ARG1 is given, then KIND,NAME pairs will be
                            read from a file of name ARG1
--modifiedentry=KIND,NAME : shows only hosts whose current interaction has
                            modified entries in of KIND kind and NAME name; if a
                            single argument ARG1 is given, then KIND,NAME pairs
                            will be read from a file of name ARG1
--extraentry=KIND,NAME    : shows only hosts whose current interaction has extra
                            entries in of KIND kind and NAME name; if a single
                            argument ARG1 is given, then KIND,NAME pairs will be
                            read from a file of name ARG1
--fields=ARG1,ARG2,...    : only displays the fields ARG1,ARG2,...
                            (name,time,state)
--sort=ARG1,ARG2,...      : sorts output on ARG1,ARG2,... (name,time,state)
--stale                   : shows hosts which haven't run in the last 24 hours
"""

def entry_generator(val):
    if ',' in val:
        yield val.split(',')
    else:
        filedata = open(val)
        for line in filedata:
            yield line.strip().split(',')

Bcfg2.Options.add_options(
    Option('-a', '--all', help='shows all hosts, including expired hosts', action='store_true'),
    Option('-b', '--bad-entries', metavar='NAME',
        help='single-host mode - shows bad entries from the current interaction of NAME'),
    Option('--only-clean', action='store_true', help='shows only clean hosts'),
    Option('-d', '--only-dirty', action='store_true', help='shows only dirty hosts'),
    Option('-e', '--extra-entries', metavar='NAME',
        help='single-host mode - shows extra entries from the current interaction of NAME'),
    Option('-m', '--modified-entries', metavar='NAME',
        help='single-host mode - shows modified entries from the current interaction of NAME'),
    Option('-s', '--single-host', metavar='NAME',
        help='single-host mode - shows bad, modified, and extra entries from the current interaction of NAME'),
    Option('-t', '--total-entries', metavar='NAME',
        help='single-host mode - shows total number of managed and good entries from the current interaction of NAME'),
    Option('-x', '--expired', metavar='NAME',
        help='toggles expired/unexpired state of NAME'),
    Option('--badentry', metavar='KIND,NAME', type=entry_generator,
        help=('shows only hosts whose current interaction has badentries in of '
              'KIND kind and NAME name; if a single argument ARG1 is given, then '
              'KIND,NAME pairs will be read from a file of name ARG1')),
    Option('--modifiedentry', metavar='KIND,NAME', type=entry_generator,
        help=('shows only hosts whose current interaction has modified entries '
              'in of KIND kind and NAME name; if a single argument ARG1 is given, '
              'then KIND,NAME pairs will be read from a file of name ARG1')),
    Option('--extraentry', metavar='KIND,NAME', type=entry_generator,
        help=('shows only hosts whose current interaction has extra entries '
              'in of KIND kind and NAME name; if a single argument ARG1 is '
              'given, then KIND,NAME pairs will be read from a file of name ARG1')),
    Option('--fields', nargs='+', metavar='ARG', default=['name', 'time', 'state'],
        choices=FIELDS,
        help='only displays the fields ARG1, ARG2,...'),
    Option('--sort', nargs='+', metavar='ARG', default=['name', 'time', 'state'],
        choices=FIELDS,
        help='sorts output on ARG1, ARG2,...'),
    Option('--stale', help="shows hosts which haven't run in the last 24 hours"),
)

c_list = Client.objects.all()

result = list()
entrydict = dict()

args = Bcfg2.Options.args()

singlehost = (args.single_host or
              args.total_entries or
              args.modified_entries or
              args.bad_entries or
              args.extra_entries)

if args.expired is not None:
    for c_inst in c_list:
        if args.expired == c_inst.name:
            if c_inst.expiration == None:
                c_inst.expiration = datetime.datetime.now()
                print("Host expired.")
            else:
                c_inst.expiration = None
                print("Host un-expired.")
            c_inst.save()

elif singlehost:
    for c_inst in c_list:
        if singlehost == c_inst.name:
            if args.total_entries:
                print_totals(c_inst)
            if args.bad_entries or args.single_host:
                print_bad(c_inst)
            if args.modified_entries or args.single_host:
                print_modified(c_inst)
            if args.extra_entries or args.single_host:
                print_extra(c_inst)

else:
    # stale hosts
    if args.stale:
        result.extend(c_inst for c_inst in c_list
                      if c_inst.current_interaction.isstale())
    # clean hosts
    elif args.only_clean:
        result.extend(c_inst for c_inst in c_list
                       if c_inst.current_interaction.isclean())
    # dirty hosts
    elif args.only_dirty:
        result.extend(c_inst for c_inst in c_list
                      if not c_inst.current_interaction.isclean())

    elif args.badentry is not None:
        result, entrydict = select_clients(
            args.badentry,
            c_list,
            lambda c: c.current_interaction.bad()
        )
    elif args.modifiedentry is not None:
        result, entrydict = select_clients(
            args.modifiedentry,
            c_list,
            lambda c: c.current_interaction.modified()
        )
    elif args.extraentry is not None:
        result, entrydict = select_clients(
            args.extraentry,
            c_list,
            lambda c: c.current_interaction.extra()
        )

    else:
        result.extend(c_list)

    if args.sort:
        result.sort(lambda x, y: crit_compare(args.sort, x, y))

    if args.fields:
        max_name = max(len(c_inst.name) for c_inst in result)
        for c_inst in result:
            if args.all or c_inst.expiration == None:
                print_fields(args.fields, c_inst, max_name, entrydict)
