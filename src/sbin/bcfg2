#!/usr/bin/env python

"""Bcfg2 Client"""
__revision__ = '$Revision$'

import fcntl
import logging
import os
import signal
import socket
import stat
import sys
import tempfile
import time
import Bcfg2.Options
import Bcfg2.Client.XML
import Bcfg2.Client.Frame
import Bcfg2.Client.Tools

import Bcfg2.Proxy
import Bcfg2.Logger

logger = logging.getLogger('bcfg2')

def cb_sigint_handler(signum, frame):
    """Exit upon CTRL-C."""
    os._exit(1)


class Client:
    """The main bcfg2 client class"""

    def __init__(self):
        self.toolset = None
        self.config = None

        Bcfg2.Options.add_options(
            Bcfg2.Options.VERBOSE,
            Bcfg2.Options.DEBUG,
            Bcfg2.Options.LOCKFILE,
            Bcfg2.Options.CLIENT_DRIVERS,
            Bcfg2.Options.CLIENT_DRYRUN,
            Bcfg2.Options.CLIENT_BUNDLE,
            Bcfg2.Options.CLIENT_BUNDLEQUICK,
            Bcfg2.Options.CLIENT_FILE,
            Bcfg2.Options.CLIENT_CACHE,
            Bcfg2.Options.CLIENT_PROFILE,
            Bcfg2.Options.CLIENT_REMOVE,
            Bcfg2.Options.SERVER_LOCATION,
            Bcfg2.Options.CLIENT_USER,
            Bcfg2.Options.SERVER_PASSWORD,
            Bcfg2.Options.OMIT_LOCK_CHECK,
            Bcfg2.Options.LOGGING_FILE_PATH,
            Bcfg2.Options.CLIENT_DLIST,
            Bcfg2.Options.CLIENT_KEY,
            Bcfg2.Options.CLIENT_CERT,
            Bcfg2.Options.CLIENT_CA,
            Bcfg2.Options.CLIENT_SCNS,
            Bcfg2.Options.CLIENT_TIMEOUT,
        )
        Bcfg2.Client.Frame.Frame.register_options()

        self.args = Bcfg2.Options.args()

        level = 30
        if self.args.verbose:
            level = 20
        if self.args.debug:
            level = 0
        Bcfg2.Logger.setup_logging('bcfg2',
                                   to_syslog=False,
                                   level=level,
                                   to_file=self.args.log_path)
        self.logger = logging.getLogger('bcfg2')
        self.logger.debug(self.args)
        if self.args.quick_bundles:
            if self.args.bundles == []:
                self.logger.error("-Q option requires -b")
                raise SystemExit(1)
            elif self.args.remove_extra != False:
                self.logger.error("-Q option incompatible with -r")
                raise SystemExit(1)
        if 'help' in self.args.drivers:
            self.logger.info("The following drivers are available:")
            self.logger.info(Bcfg2.Client.Tools.drivers)
            raise SystemExit(0)
        if self.args.remove_extra in ['services', 'Services']:
            self.logger.error("Service removal is nonsensical; removed services will only be disabled")
        if (self.args.from_file is not None) and (self.args.cache is not None):
            print("cannot use -f and -c together")
            raise SystemExit(1)
        if not self.args.server_location.startswith('https://'):
            self.args.server_location = 'https://' + self.args.server_location

    def run_probe(self, probe):
        """Execute probe."""
        name = probe.get('name')
        self.logger.info("Running probe %s" % name)
        ret = Bcfg2.Client.XML.Element("probe-data",
                                       name=name,
                                       source=probe.get('source'))
        try:
            scripthandle, scriptname = tempfile.mkstemp()
            script = open(scriptname, 'w+')
            try:
                script.write("#!%s\n" %
                             (probe.attrib.get('interpreter', '/bin/sh')))
                script.write(probe.text)
                script.close()
                os.close(scripthandle)
                os.chmod(script.name, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH |
                                      stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH |
                                      stat.S_IWUSR)  # 0755
                ret.text = os.popen(script.name).read().strip()
                self.logger.info("Probe %s has result:\n%s" % (name, ret.text))
            finally:
                os.unlink(script.name)
        except:
            self.logger.error("Failed to execute probe: %s" % (name), exc_info=1)
            raise SystemExit(1)
        return ret

    def fatal_error(self, message):
        """Signal a fatal error."""
        self.logger.error("Fatal error: %s" % (message))
        os._exit(1)

    def run(self):
        """Perform client execution phase."""
        times = {}

        # begin configuration
        times['start'] = time.time()

        if self.args.from_file:
            # read config from file
            try:
                self.logger.debug("Reading cached configuration from %s" %
                                  (self.args.from_file.name))
                rawconfig = self.args.from_file.read()
            except IOError:
                self.fatal_error("Failed to read cached configuration from: %s"
                                 % (self.args.from_file.name))
                return(1)
        else:
            # retrieve config from server
            proxy = Bcfg2.Proxy.ComponentProxy(self.args.server_location,
                                               self.args.user,
                                               self.args.password,
                                               key=self.args.ssl_key,
                                               cert=self.args.ssl_cert,
                                               ca=self.args.ca_cert,
                                               allowedServerCNs=self.args.ssl_cns,
                                               timeout=self.args.timeout)

            if self.args.profile:
                try:
                    proxy.AssertProfile(self.args.profile)
                except Bcfg2.Proxy.ProxyError:
                    err = sys.exc_info()[1]
                    self.fatal_error("Failed to set client profile")
                    self.logger.error(str(err))
                    raise SystemExit(1)

            try:
                probe_data = proxy.GetProbes()
            except (Bcfg2.Proxy.ProxyError,
                    Bcfg2.Proxy.CertificateError,
                    socket.gaierror,
                    socket.error):
                err = sys.exc_info()[1]
                self.logger.error("Failed to download probes from bcfg2: %s" %
                                  err)
                raise SystemExit(1)

            times['probe_download'] = time.time()

            try:
                probes = Bcfg2.Client.XML.XML(probe_data)
            except Bcfg2.Client.XML.ParseError:
                syntax_error = sys.exc_info()[1]
                self.fatal_error(
                    "Server returned invalid probe requests: %s" %
                    (syntax_error))
                return(1)

            # execute probes
            try:
                probedata = Bcfg2.Client.XML.Element("ProbeData")
                [probedata.append(self.run_probe(probe))
                 for probe in probes.findall(".//probe")]
            except:
                self.logger.error("Failed to execute probes")
                raise SystemExit(1)

            if len(probes.findall(".//probe")) > 0:
                try:
                    # upload probe responses
                    proxy.RecvProbeData(Bcfg2.Client.XML.tostring(probedata,
                                                                  encoding='UTF-8',
                                                                  xml_declaration=True))
                except Bcfg2.Proxy.ProxyError:
                    err = sys.exc_info()[1]
                    self.logger.error("Failed to upload probe data: %s" % err)
                    raise SystemExit(1)

            times['probe_upload'] = time.time()

            if self.args.decision in ['whitelist', 'blacklist']:
                try:
                    self.decision_list = \
                        proxy.GetDecisionList(self.args.decision)
                    self.logger.info("Got decision list from server:")
                    self.logger.info(self.decision_list)
                except Bcfg2.Proxy.ProxyError:
                    err = sys.exc_info()[1]
                    self.logger.error("Failed to get decision list: %s" % err)
                    raise SystemExit(1)

            try:
                rawconfig = proxy.GetConfig().encode('UTF-8')
            except Bcfg2.Proxy.ProxyError:
                err = sys.exc_info()[1]
                self.logger.error("Failed to download configuration from "
                                  "Bcfg2: %s" % err)
                raise SystemExit(2)

            times['config_download'] = time.time()

        if self.args.cache:
            try:
                self.args.cache.write(rawconfig)
                os.chmod(self.args.cache.name, 33152)
            except IOError:
                self.logger.warning("Failed to write config cache file %s" %
                                    (self.args.cache.name))
            times['caching'] = time.time()

        try:
            self.config = Bcfg2.Client.XML.XML(rawconfig)
        except Bcfg2.Client.XML.ParseError:
            syntax_error = sys.exc_info()[1]
            self.fatal_error("The configuration could not be parsed: %s" %
                             (syntax_error))
            return(1)

        times['config_parse'] = time.time()

        if self.config.tag == 'error':
            self.fatal_error("Server error: %s" % (self.config.text))
            return(1)

        if self.args.quick_bundles:
            newconfig = Bcfg2.Client.XML.XML('<Configuration/>')
            [newconfig.append(bundle) for bundle in self.config.getchildren() if \
             bundle.tag == 'Bundle' and bundle.get('name') in self.args.bundles]
            self.config = newconfig

        self.tools = Bcfg2.Client.Frame.Frame(self.config,
                                              self.args,
                                              times, self.args.drivers,
                                              self.args.dryrun)

        if not self.args.omit_lock_check:
            #check lock here
            try:
                lockfile = open(self.args.components_lockfile, 'w')
                try:
                    fcntl.lockf(lockfile.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
                except IOError:
                    #otherwise exit and give a warning to the user
                    self.fatal_error("An other instance of Bcfg2 is running. If you what to bypass the check, run with %s option" %
                                     (Bcfg2.Options.OMIT_LOCK_CHECK.cmd))
            except:
                lockfile = None
                self.logger.error("Failed to open lockfile")
        # execute the said configuration
        self.tools.Execute()

        if not self.args.omit_lock_check:
            #unlock here
            if lockfile:
                try:
                    fcntl.lockf(lockfile.fileno(), fcntl.LOCK_UN)
                    os.remove(self.args.components_lockfile)
                except OSError:
                    self.logger.error("Failed to unlock lockfile %s" % lockfile.name)

        if not self.args.from_file and not self.args.quick_bundles:
            # upload statistics
            feedback = self.tools.GenerateStats()

            try:
                proxy.RecvStats(Bcfg2.Client.XML.tostring(feedback,
                                                          encoding='UTF-8',
                                                          xml_declaration=True))
            except Bcfg2.Proxy.ProxyError:
                err = sys.exc_info()[1]
                self.logger.error("Failed to upload configuration statistics: "
                                  "%s" % err)
                raise SystemExit(2)

if __name__ == '__main__':
    signal.signal(signal.SIGINT, cb_sigint_handler)
    client = Client()
    spid = os.getpid()
    client.run()
